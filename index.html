<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AIZoomAgent</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #000; color: #fff; }
    #canvas { border: 2px solid #ff0; }
    #hype-meter { position: absolute; top: 10px; left: 10px; font-size: 24px; }
    #meme-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 300px; display: none; opacity: 0; transition: opacity 2s; }
    #meme-overlay.show { display: block; opacity: 1; }
    #vibe-log { position: absolute; top: 50px; left: 10px; font-size: 18px; }
    #avatar-container { position: absolute; top: 100px; left: 100px; opacity: 0; transition: opacity 2s; }
    #avatar-container.show { opacity: 1; }
    button, select, input { padding: 10px; margin: 5px; background: #ff0; color: #000; border: none; font-size: 18px; cursor: pointer; }
    #custom-directive { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas" width="1280" height="720"></canvas>
  <div id="hype-meter">Hype Score: 0</div>
  <div id="vibe-log">Vibe: Detecting...</div>
  <img id="meme-overlay" src="">
  <div id="avatar-container">
    <img id="avatar-img" src="">
  </div>
  <div>
    <button onclick="dropMeme('https://i.imgflip.com/5z5x0m.jpg')">Talk Shit, Get Hit</button>
    <button onclick="generateAgent()">Generate AIZoomAgent</button>
    <select id="directive" onchange="toggleCustomDirective()">
      <option value="match">Match Vibe</option>
      <option value="hype">Hype the Room</option>
      <option value="roast">Roast Presenter</option>
      <option value="custom">Custom</option>
    </select>
    <input id="custom-directive" type="text" placeholder="Enter custom prompt">
    <button onclick="applyDirective()">Apply Directive</button>
    <input id="chat-input" type="text" placeholder="Type Zoom chat (paste URLs)">
    <button onclick="analyzeChat()">Vibe Check</button>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js"></script>
  <!-- TensorFlow.js for vision -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
  <!-- Tesseract.js for text -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
  <!-- YOLOv5 for object detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

  <script>
    // Firebase config (your provided values)
    const firebaseConfig = {
      apiKey: "AIzaSyBONwaRl23VeTJISmiQ3X-t3y6FGK7Ngjc",
      authDomain: "tglsmarthub.firebaseapp.com",
      projectId: "tglsmarthub",
      storageBucket: "tglsmarthub.firebasestorage.app",
      messagingSenderId: "361291241205",
      appId: "1:361291241205:web:854f79a0238e6e4795d7bc",
      measurementId: "G-LQ4BP8GG37"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // Canvas and setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const memeOverlay = document.getElementById('meme-overlay');
    const avatarImg = document.getElementById('avatar-img');
    const avatarContainer = document.getElementById('avatar-container');
    const hypeMeter = document.getElementById('hype-meter');
    const vibeLog = document.getElementById('vibe-log');
    let hypeScore = 0;
    let vibe = 'neutral';
    let dominantColors = [];
    let commonObjects = [];
    let lastVibeState = null;
    let chatMemes = [];

    // Load models
    let faceModel, objectModel;
    async function loadModels() {
      faceModel = await blazeface.load();
      objectModel = await cocoSsd.load();
    }
    loadModels();

    // Analyze screen
    async function analyzeCams(video) {
      const predictions = await faceModel.estimateFaces(video, false);
      const objects = await objectModel.detect(video);
      let emotions = [];
      dominantColors = [];
      commonObjects = [];
      let screenText = '';

      // Color detection
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
      let r = 0, g = 0, b = 0, count = 0;
      for (let i = 0; i < imgData.length; i += 4) {
        r += imgData[i];
        g += imgData[i + 1];
        b += imgData[i + 2];
        count++;
      }
      dominantColors.push(`rgb(${r/count},${g/count},${b/count})`);

      // Emotion detection
      if (predictions.length > 0) {
        emotions = predictions.map(p => p.landmarks[4][1] > p.landmarks[5][1] ? 'happy' : 'bored');
        vibe = emotions.reduce((a, b) => emotions.filter(v => v === a).length >= emotions.filter(v => v === b).length ? a : b);
      } else {
        vibe = 'neutral';
      }

      // Object detection
      commonObjects = objects.map(o => o.class);

      // Text detection
      const { data: { text } } = await Tesseract.recognize(video, 'eng');
      screenText = text.toLowerCase();
      if (screenText.includes('synergy') || screenText.includes('kpi')) {
        vibe = 'corporate';
        dropMeme(chatMemes.length ? chatMemes[0] : 'https://i.imgflip.com/789xyz.jpg');
      }

      // Save vibe state
      lastVibeState = { vibe, dominantColors, commonObjects, screenText };
      db.ref('vibes').push(lastVibeState);
      vibeLog.textContent = `Vibe: ${vibe} | Text: ${screenText.substring(0, 50)}...`;
    }

    // Generate hyperrealistic avatar
    async function generateAgent(directive = 'match') {
      let prompt = '';
      if (directive === 'hype') prompt = `Hyperrealistic person, excited expression, vibrant clothes matching ${dominantColors[0] || 'rgb(255,255,255)'}, in a party background`;
      else if (directive === 'roast') prompt = `Hyperrealistic person, sarcastic expression, dark clothes matching ${dominantColors[0] || 'rgb(0,0,0)'}, in a ${commonObjects.length ? commonObjects[0] : 'office'} background`;
      else if (directive === 'custom') prompt = document.getElementById('custom-directive').value || `Hyperrealistic person, neutral expression, in a modern office`;
      else prompt = `Hyperrealistic person, ${lastVibeState?.vibe || 'neutral'} expression, wearing clothes matching ${lastVibeState?.dominantColors[0] || 'rgb(255,255,255)'}, in a ${lastVibeState?.commonObjects[0] || 'modern office'} background`;

      avatarContainer.classList.remove('show');
      setTimeout(async () => {
        const avatarUrl = await stableDiffusionAPI(prompt);
        avatarImg.src = avatarUrl;
        avatarContainer.classList.add('show');
        db.ref('avatars').push({ url: avatarUrl, vibe: lastVibeState?.vibe || 'neutral', timestamp: Date.now() });
      }, 2000);
    }

    // Stable Diffusion API
    async function stableDiffusionAPI(prompt) {
      const response = await fetch("https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-2-1", {
        method: "POST",
        headers: {
          "Authorization": "Bearer L3NumhFtiEZbTBoIFQmFW8fywmei1IwJNYijhXb2GRz2zRmPgf5i3XzJ1ZXY", // Your key
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ inputs: prompt })
      });
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    }

    // Meme drop function
    function dropMeme(url) {
      memeOverlay.classList.remove('show');
      setTimeout(() => {
        memeOverlay.src = url;
        memeOverlay.classList.add('show');
        setTimeout(() => memeOverlay.classList.remove('show'), 3000);
        db.ref('memes').push({ url, timestamp: Date.now() });
      }, 2000);
    }

    // Chat vibe check
    function analyzeChat() {
      const chat = document.getElementById('chat-input').value.toLowerCase();
      const urlRegex = /(https?:\/\/[^\s]+\.(jpg|png|gif))/gi;
      chatMemes = (chat.match(urlRegex) || []).filter(url => url.includes('imgflip') || url.includes('giphy'));
      if (chat.includes('shit') || chat.includes('fuck')) {
        hypeScore += 20;
        vibe = 'hype';
        dropMeme(chatMemes.length ? chatMemes[0] : 'https://i.imgflip.com/5z5x0m.jpg');
      } else {
        hypeScore += 5;
        vibe = 'chill';
      }
      lastVibeState = { vibe, dominantColors, commonObjects, screenText: chat };
      db.ref('vibes').push(lastVibeState);
      vibeLog.textContent = `Vibe: ${vibe} | Memes: ${chatMemes.length}`;
      hypeMeter.textContent = `Hype Score: ${hypeScore}`;
      db.ref('hype').set(hypeScore);
    }

    // Directive handling
    function toggleCustomDirective() {
      const directive = document.getElementById('directive').value;
      document.getElementById('custom-directive').style.display = directive === 'custom' ? 'block' : 'none';
    }

    function applyDirective() {
      const directive = document.getElementById('directive').value;
      generateAgent(directive);
    }

    // Virtual camera setup
    let isScreenSharing = false;
    async function startVirtualCamera() {
      const stream = canvas.captureStream(30);
      const video = document.createElement('video');
      try {
        // Try VDO.Ninja for screen share
        const peerConnection = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        peerConnection.ontrack = (event) => {
          video.srcObject = event.streams[0];
          isScreenSharing = true;
        };
        const offer = await fetch('https://vdo.ninja/?push=YOUR_VDO_NINJA_ID/offer', { method: 'POST' }).then(res => res.json());
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        await fetch('https://vdo.ninja/?push=YOUR_VDO_NINJA_ID/answer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(answer)
        });
      } catch (e) {
        // Fallback to last vibe state
        isScreenSharing = false;
        db.ref('vibes').orderByChild('timestamp').limitToLast(1).once('value', snapshot => {
          lastVibeState = snapshot.val() ? Object.values(snapshot.val())[0] : { vibe: 'neutral', dominantColors: ['rgb(255,255,255)'], commonObjects: ['office'] };
          vibeLog.textContent = `Vibe: ${lastVibeState.vibe} (Using last state)`;
        });
      }
      video.play();
      video.onloadedmetadata = () => {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (isScreenSharing) analyzeCams(video);
        setInterval(() => {
          if (isScreenSharing) analyzeCams(video);
          else generateAgent();
        }, 5000);
      };
    }
    startVirtualCamera();

    // Animation loop
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '20px Arial';
      ctx.fillText('AIZoomAgent', 20, 50);
      requestAnimationFrame(draw);
    }
    draw();

    // Voice detection
    const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
    recognition.continuous = true;
    recognition.onresult = (event) => {
      const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase();
      if (transcript.includes('synergy') || transcript.includes('kpi')) {
        vibe = 'corporate';
        dropMeme(chatMemes.length ? chatMemes[0] : 'https://i.imgflip.com/789xyz.jpg');
        lastVibeState = { vibe, dominantColors, commonObjects, screenText: transcript };
        db.ref('vibes').push(lastVibeState);
      }
    };
    recognition.start();
  </script>

  <!-- Service Worker -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(reg => console.log('Service Worker Registered'))
        .catch(err => console.error('Service Worker Failed:', err));
    }
  </script>
</body>
</html>
